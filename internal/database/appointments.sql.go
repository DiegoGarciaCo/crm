// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: appointments.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createAppointment = `-- name: CreateAppointment :one
INSERT INTO
    appointments (
        assigned_to_id,
        contact_id,
        title,
        scheduled_at,
        location,
        TYPE,
        outcome,
        note
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8
    )
RETURNING
    id, contact_id, assigned_to_id, title, scheduled_at, location, type, outcome, note, created_at, updated_at
`

type CreateAppointmentParams struct {
	AssignedToID uuid.NullUUID
	ContactID    uuid.NullUUID
	Title        string
	ScheduledAt  time.Time
	Location     sql.NullString
	Type         NullAppointmentType
	Outcome      NullAppointmentOutcome
	Note         sql.NullString
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRowContext(ctx, createAppointment,
		arg.AssignedToID,
		arg.ContactID,
		arg.Title,
		arg.ScheduledAt,
		arg.Location,
		arg.Type,
		arg.Outcome,
		arg.Note,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.AssignedToID,
		&i.Title,
		&i.ScheduledAt,
		&i.Location,
		&i.Type,
		&i.Outcome,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAppointment = `-- name: DeleteAppointment :exec
DELETE FROM
    appointments
WHERE
    id = $1
`

func (q *Queries) DeleteAppointment(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAppointment, id)
	return err
}

const getAppointmentById = `-- name: GetAppointmentById :one
SELECT
    id, contact_id, assigned_to_id, title, scheduled_at, location, type, outcome, note, created_at, updated_at
FROM
    appointments
WHERE
    id = $1
`

func (q *Queries) GetAppointmentById(ctx context.Context, id uuid.UUID) (Appointment, error) {
	row := q.db.QueryRowContext(ctx, getAppointmentById, id)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.AssignedToID,
		&i.Title,
		&i.ScheduledAt,
		&i.Location,
		&i.Type,
		&i.Outcome,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAppointments = `-- name: ListAppointments :many
SELECT
    id, contact_id, assigned_to_id, title, scheduled_at, location, type, outcome, note, created_at, updated_at
FROM
    appointments
WHERE
    assigned_to_id = $1
ORDER BY
    scheduled_at ASC
`

func (q *Queries) ListAppointments(ctx context.Context, assignedToID uuid.NullUUID) ([]Appointment, error) {
	rows, err := q.db.QueryContext(ctx, listAppointments, assignedToID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Appointment
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.AssignedToID,
			&i.Title,
			&i.ScheduledAt,
			&i.Location,
			&i.Type,
			&i.Outcome,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointmentsByContactId = `-- name: ListAppointmentsByContactId :many
SELECT
    id, contact_id, assigned_to_id, title, scheduled_at, location, type, outcome, note, created_at, updated_at
FROM
    appointments
WHERE
    contact_id = $1
ORDER BY
    scheduled_at ASC
`

func (q *Queries) ListAppointmentsByContactId(ctx context.Context, contactID uuid.NullUUID) ([]Appointment, error) {
	rows, err := q.db.QueryContext(ctx, listAppointmentsByContactId, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Appointment
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.AssignedToID,
			&i.Title,
			&i.ScheduledAt,
			&i.Location,
			&i.Type,
			&i.Outcome,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPastAppointments = `-- name: ListPastAppointments :many
SELECT
    id, contact_id, assigned_to_id, title, scheduled_at, location, type, outcome, note, created_at, updated_at
FROM
    appointments
WHERE
    scheduled_at < NOW()
    AND assigned_to_id = $1
ORDER BY
    scheduled_at DESC
`

func (q *Queries) ListPastAppointments(ctx context.Context, assignedToID uuid.NullUUID) ([]Appointment, error) {
	rows, err := q.db.QueryContext(ctx, listPastAppointments, assignedToID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Appointment
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.AssignedToID,
			&i.Title,
			&i.ScheduledAt,
			&i.Location,
			&i.Type,
			&i.Outcome,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodaysAppointments = `-- name: ListTodaysAppointments :many
SELECT
    id, contact_id, assigned_to_id, title, scheduled_at, location, type, outcome, note, created_at, updated_at
FROM
    appointments
WHERE
    scheduled_at::date = current_date
    AND assigned_to_id = $1
ORDER BY
    scheduled_at ASC
`

func (q *Queries) ListTodaysAppointments(ctx context.Context, assignedToID uuid.NullUUID) ([]Appointment, error) {
	rows, err := q.db.QueryContext(ctx, listTodaysAppointments, assignedToID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Appointment
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.AssignedToID,
			&i.Title,
			&i.ScheduledAt,
			&i.Location,
			&i.Type,
			&i.Outcome,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingAppointments = `-- name: ListUpcomingAppointments :many
SELECT
    id, contact_id, assigned_to_id, title, scheduled_at, location, type, outcome, note, created_at, updated_at
FROM
    appointments
WHERE
    scheduled_at > NOW()
    AND assigned_to_id = $1
ORDER BY
    scheduled_at ASC
`

func (q *Queries) ListUpcomingAppointments(ctx context.Context, assignedToID uuid.NullUUID) ([]Appointment, error) {
	rows, err := q.db.QueryContext(ctx, listUpcomingAppointments, assignedToID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Appointment
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.AssignedToID,
			&i.Title,
			&i.ScheduledAt,
			&i.Location,
			&i.Type,
			&i.Outcome,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAppointment = `-- name: UpdateAppointment :one
UPDATE
    appointments
SET
    contact_id = $2,
    title = $3,
    scheduled_at = $4,
    location = $5,
    TYPE = $6,
    outcome = $7,
    note = $8
WHERE
    id = $1
RETURNING
    id, contact_id, assigned_to_id, title, scheduled_at, location, type, outcome, note, created_at, updated_at
`

type UpdateAppointmentParams struct {
	ID          uuid.UUID
	ContactID   uuid.NullUUID
	Title       string
	ScheduledAt time.Time
	Location    sql.NullString
	Type        NullAppointmentType
	Outcome     NullAppointmentOutcome
	Note        sql.NullString
}

func (q *Queries) UpdateAppointment(ctx context.Context, arg UpdateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRowContext(ctx, updateAppointment,
		arg.ID,
		arg.ContactID,
		arg.Title,
		arg.ScheduledAt,
		arg.Location,
		arg.Type,
		arg.Outcome,
		arg.Note,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.AssignedToID,
		&i.Title,
		&i.ScheduledAt,
		&i.Location,
		&i.Type,
		&i.Outcome,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
