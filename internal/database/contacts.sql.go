// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: contacts.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const bulkInsertContacts = `-- name: BulkInsertContacts :many
INSERT INTO
    contacts (
        first_name,
        last_name,
        birthdate,
        source,
        STATUS,
        address,
        city,
        state,
        zip_code,
        lender,
        price_range,
        timeframe,
        owner_id
    )
SELECT
    unnest($1::text []),
    unnest($2::text []),
    unnest($3::date []),
    unnest($4::text []),
    unnest($5::text []),
    unnest($6::text []),
    unnest($7::text []),
    unnest($8::text []),
    unnest($9::text []),
    unnest($10::text []),
    unnest($11::text []),
    unnest($12::text []),
    unnest($13::uuid [])
RETURNING
    id, first_name, last_name, birthdate, source, status, address, city, state, zip_code, lender, price_range, timeframe, owner_id, created_at, updated_at, last_contacted_at
`

type BulkInsertContactsParams struct {
	FirstNames  []string
	LastNames   []string
	Birthdates  []time.Time
	Sources     []string
	Statuses    []string
	Addresses   []string
	Cities      []string
	States      []string
	ZipCodes    []string
	Lenders     []string
	PriceRanges []string
	Timeframes  []string
	OwnerIds    []uuid.UUID
}

func (q *Queries) BulkInsertContacts(ctx context.Context, arg BulkInsertContactsParams) ([]Contact, error) {
	rows, err := q.db.QueryContext(ctx, bulkInsertContacts,
		pq.Array(arg.FirstNames),
		pq.Array(arg.LastNames),
		pq.Array(arg.Birthdates),
		pq.Array(arg.Sources),
		pq.Array(arg.Statuses),
		pq.Array(arg.Addresses),
		pq.Array(arg.Cities),
		pq.Array(arg.States),
		pq.Array(arg.ZipCodes),
		pq.Array(arg.Lenders),
		pq.Array(arg.PriceRanges),
		pq.Array(arg.Timeframes),
		pq.Array(arg.OwnerIds),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contact
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Birthdate,
			&i.Source,
			&i.Status,
			&i.Address,
			&i.City,
			&i.State,
			&i.ZipCode,
			&i.Lender,
			&i.PriceRange,
			&i.Timeframe,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastContactedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createContact = `-- name: CreateContact :one
INSERT INTO
    contacts (
        first_name,
        last_name,
        birthdate,
        source,
        STATUS,
        address,
        city,
        state,
        zip_code,
        lender,
        price_range,
        timeframe,
        owner_id
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13
    )
RETURNING
    id, first_name, last_name, birthdate, source, status, address, city, state, zip_code, lender, price_range, timeframe, owner_id, created_at, updated_at, last_contacted_at
`

type CreateContactParams struct {
	FirstName  string
	LastName   string
	Birthdate  sql.NullTime
	Source     sql.NullString
	Status     sql.NullString
	Address    sql.NullString
	City       sql.NullString
	State      sql.NullString
	ZipCode    sql.NullString
	Lender     sql.NullString
	PriceRange sql.NullString
	Timeframe  sql.NullString
	OwnerID    uuid.NullUUID
}

func (q *Queries) CreateContact(ctx context.Context, arg CreateContactParams) (Contact, error) {
	row := q.db.QueryRowContext(ctx, createContact,
		arg.FirstName,
		arg.LastName,
		arg.Birthdate,
		arg.Source,
		arg.Status,
		arg.Address,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.Lender,
		arg.PriceRange,
		arg.Timeframe,
		arg.OwnerID,
	)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Birthdate,
		&i.Source,
		&i.Status,
		&i.Address,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.Lender,
		&i.PriceRange,
		&i.Timeframe,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastContactedAt,
	)
	return i, err
}

const createContactWithDetails = `-- name: CreateContactWithDetails :one
WITH new_contact AS (
    INSERT INTO
        contacts(
            first_name,
            last_name,
            birthdate,
            source,
            STATUS,
            address,
            city,
            state,
            zip_code,
            lender,
            price_range,
            timeframe,
            owner_id
        )
    VALUES
        (
            $1,
            $2,
            $3,
            $4,
            $5,
            $6,
            $7,
            $8,
            $9,
            $10,
            $11,
            $12,
            $13
        )
    RETURNING
        id
),
insert_phones AS (
    INSERT INTO
        phone_numbers(contact_id, phone_number, TYPE, is_primary)
    SELECT
        id,
        phone_number,
        TYPE,
        is_primary
    FROM
        new_contact,
        jsonb_to_recordset($14::jsonb) AS p(
            phone_number text,
            TYPE text,
            is_primary boolean
        )
),
insert_emails AS (
    INSERT INTO
        emails(contact_id, email_address, TYPE, is_primary)
    SELECT
        id,
        email_address,
        TYPE,
        is_primary
    FROM
        new_contact,
        jsonb_to_recordset($15::jsonb) AS e(
            email_address text,
            TYPE text,
            is_primary boolean
        )
)
SELECT
    id
FROM
    new_contact
`

type CreateContactWithDetailsParams struct {
	FirstName  string
	LastName   string
	Birthdate  sql.NullTime
	Source     sql.NullString
	Status     sql.NullString
	Address    sql.NullString
	City       sql.NullString
	State      sql.NullString
	ZipCode    sql.NullString
	Lender     sql.NullString
	PriceRange sql.NullString
	Timeframe  sql.NullString
	OwnerID    uuid.NullUUID
	Phones     json.RawMessage
	Emails     json.RawMessage
}

func (q *Queries) CreateContactWithDetails(ctx context.Context, arg CreateContactWithDetailsParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createContactWithDetails,
		arg.FirstName,
		arg.LastName,
		arg.Birthdate,
		arg.Source,
		arg.Status,
		arg.Address,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.Lender,
		arg.PriceRange,
		arg.Timeframe,
		arg.OwnerID,
		arg.Phones,
		arg.Emails,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getAllContacts = `-- name: GetAllContacts :many
SELECT
    c.id, c.first_name, c.last_name, c.birthdate, c.source, c.status, c.address, c.city, c.state, c.zip_code, c.lender, c.price_range, c.timeframe, c.owner_id, c.created_at, c.updated_at, c.last_contacted_at,
    coalesce(
        (
            SELECT
                json_agg(p.*)::text
            FROM
                phone_numbers p
            WHERE
                p.contact_id = c.id
        ),
        '[]'
    ) AS phone_numbers,
    count(c.*) AS total_count
FROM
    contacts c
    LEFT JOIN phone_numbers p ON p.contact_id = c.id
WHERE
    c.owner_id = $3
GROUP BY
    c.id
ORDER BY
    c.created_at DESC
LIMIT
    $1 OFFSET $2
`

type GetAllContactsParams struct {
	Limit   int32
	Offset  int32
	OwnerID uuid.NullUUID
}

type GetAllContactsRow struct {
	ID              uuid.UUID
	FirstName       string
	LastName        string
	Birthdate       sql.NullTime
	Source          sql.NullString
	Status          sql.NullString
	Address         sql.NullString
	City            sql.NullString
	State           sql.NullString
	ZipCode         sql.NullString
	Lender          sql.NullString
	PriceRange      sql.NullString
	Timeframe       sql.NullString
	OwnerID         uuid.NullUUID
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
	LastContactedAt sql.NullTime
	PhoneNumbers    interface{}
	TotalCount      int64
}

func (q *Queries) GetAllContacts(ctx context.Context, arg GetAllContactsParams) ([]GetAllContactsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllContacts, arg.Limit, arg.Offset, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllContactsRow
	for rows.Next() {
		var i GetAllContactsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Birthdate,
			&i.Source,
			&i.Status,
			&i.Address,
			&i.City,
			&i.State,
			&i.ZipCode,
			&i.Lender,
			&i.PriceRange,
			&i.Timeframe,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastContactedAt,
			&i.PhoneNumbers,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContactWithDetails = `-- name: GetContactWithDetails :one
SELECT
    c.id, c.first_name, c.last_name, c.birthdate, c.source, c.status, c.address, c.city, c.state, c.zip_code, c.lender, c.price_range, c.timeframe, c.owner_id, c.created_at, c.updated_at, c.last_contacted_at,
    coalesce(
        (
            SELECT
                json_agg(e.*)::text
            FROM
                emails e
            WHERE
                e.contact_id = c.id
        ),
        '[]'
    ) AS emails,
    coalesce(
        (
            SELECT
                json_agg(p.*)::text
            FROM
                phone_numbers p
            WHERE
                p.contact_id = c.id
        ),
        '[]'
    ) AS phone_numbers,
    coalesce(
        (
            SELECT
                json_agg(t.*)::text
            FROM
                tags t
                JOIN contact_tags ct ON ct.tag_id = t.id
            WHERE
                ct.contact_id = c.id
        ),
        '[]'
    ) AS tags,
    coalesce(
        (
            SELECT
                json_agg(
                    json_build_object('id', u.id, 'name', u.name, 'role', cb.role)
                )::text
            FROM
                collaborators cb
                JOIN users u ON cb.user_id = u.id
            WHERE
                cb.contact_id = c.id
        ),
        '[]'
    ) AS collaborators
FROM
    contacts c
WHERE
    c.id = $1
`

type GetContactWithDetailsRow struct {
	ID              uuid.UUID
	FirstName       string
	LastName        string
	Birthdate       sql.NullTime
	Source          sql.NullString
	Status          sql.NullString
	Address         sql.NullString
	City            sql.NullString
	State           sql.NullString
	ZipCode         sql.NullString
	Lender          sql.NullString
	PriceRange      sql.NullString
	Timeframe       sql.NullString
	OwnerID         uuid.NullUUID
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
	LastContactedAt sql.NullTime
	Emails          interface{}
	PhoneNumbers    interface{}
	Tags            interface{}
	Collaborators   interface{}
}

func (q *Queries) GetContactWithDetails(ctx context.Context, id uuid.UUID) (GetContactWithDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getContactWithDetails, id)
	var i GetContactWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Birthdate,
		&i.Source,
		&i.Status,
		&i.Address,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.Lender,
		&i.PriceRange,
		&i.Timeframe,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastContactedAt,
		&i.Emails,
		&i.PhoneNumbers,
		&i.Tags,
		&i.Collaborators,
	)
	return i, err
}

const getContactsBySmartList = `-- name: GetContactsBySmartList :many
SELECT
    c.id,
    c.first_name,
    c.last_name,
    c.birthdate,
    c.source,
    c.status,
    c.address,
    c.city,
    c.state,
    c.zip_code,
    c.lender,
    c.price_range,
    c.timeframe,
    c.owner_id,
    c.last_contacted_at,
    c.created_at,
    c.updated_at,
    count(c.*) AS total_count
FROM
    contacts c
    LEFT JOIN contact_tags ct ON ct.contact_id = c.id
    LEFT JOIN tags t ON t.id = ct.tag_id
    JOIN smart_lists s ON s.id = $1
WHERE
    (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'first_name' IS NULL
        OR c.first_name ilike '%' || (
            coalesce(s.filter_criteria, '{}'::jsonb) ->> 'first_name'
        ) || '%'
    )
    AND (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'last_name' IS NULL
        OR c.last_name ilike '%' || (
            coalesce(s.filter_criteria, '{}'::jsonb) ->> 'last_name'
        ) || '%'
    )
    AND (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'birthdate' IS NULL
        OR c.birthdate = (
            coalesce(s.filter_criteria, '{}'::jsonb) ->> 'birthdate'
        )::date
    )
    AND (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'source' IS NULL
        OR c.source ilike '%' || (
            coalesce(s.filter_criteria, '{}'::jsonb) ->> 'source'
        ) || '%'
    )
    AND (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'status' IS NULL
        OR c.status = (
            coalesce(s.filter_criteria, '{}'::jsonb) ->> 'status'
        )
    )
    AND (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'address' IS NULL
        OR c.address ilike '%' || (
            coalesce(s.filter_criteria, '{}'::jsonb) ->> 'address'
        ) || '%'
    )
    AND (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'city' IS NULL
        OR c.city ilike '%' || (
            coalesce(s.filter_criteria, '{}'::jsonb) ->> 'city'
        ) || '%'
    )
    AND (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'state' IS NULL
        OR c.state ilike '%' || (
            coalesce(s.filter_criteria, '{}'::jsonb) ->> 'state'
        ) || '%'
    )
    AND (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'zip_code' IS NULL
        OR c.zip_code = (
            coalesce(s.filter_criteria, '{}'::jsonb) ->> 'zip_code'
        )
    )
    AND (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'lender' IS NULL
        OR c.lender ilike '%' || (
            coalesce(s.filter_criteria, '{}'::jsonb) ->> 'lender'
        ) || '%'
    )
    AND (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'price_range' IS NULL
        OR c.price_range = (
            coalesce(s.filter_criteria, '{}'::jsonb) ->> 'price_range'
        )
    )
    AND (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'timeframe' IS NULL
        OR c.timeframe = (
            coalesce(s.filter_criteria, '{}'::jsonb) ->> 'timeframe'
        )
    )
    AND (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'owner_id' IS NULL
        OR c.owner_id = (
            coalesce(s.filter_criteria, '{}'::jsonb) ->> 'owner_id'
        )::uuid
    )
    AND (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'tag_id' IS NULL
        OR t.id = (
            coalesce(s.filter_criteria, '{}'::jsonb) ->> 'tag_id'
        )::uuid
    )
    AND (
        coalesce(s.filter_criteria, '{}'::jsonb) ->> 'last_contacted_days' IS NULL
        OR c.last_contacted_at <= NOW() - (
            (
                coalesce(s.filter_criteria, '{}'::jsonb) ->> 'last_contacted_days'
            ) || ' days'
        )::INTERVAL
    )
ORDER BY
    c.last_contacted_at ASC nulls FIRST,
    c.created_at DESC
LIMIT
    $2 OFFSET $3
`

type GetContactsBySmartListParams struct {
	ID     uuid.UUID
	Limit  int32
	Offset int32
}

type GetContactsBySmartListRow struct {
	ID              uuid.UUID
	FirstName       string
	LastName        string
	Birthdate       sql.NullTime
	Source          sql.NullString
	Status          sql.NullString
	Address         sql.NullString
	City            sql.NullString
	State           sql.NullString
	ZipCode         sql.NullString
	Lender          sql.NullString
	PriceRange      sql.NullString
	Timeframe       sql.NullString
	OwnerID         uuid.NullUUID
	LastContactedAt sql.NullTime
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
	TotalCount      int64
}

func (q *Queries) GetContactsBySmartList(ctx context.Context, arg GetContactsBySmartListParams) ([]GetContactsBySmartListRow, error) {
	rows, err := q.db.QueryContext(ctx, getContactsBySmartList, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContactsBySmartListRow
	for rows.Next() {
		var i GetContactsBySmartListRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Birthdate,
			&i.Source,
			&i.Status,
			&i.Address,
			&i.City,
			&i.State,
			&i.ZipCode,
			&i.Lender,
			&i.PriceRange,
			&i.Timeframe,
			&i.OwnerID,
			&i.LastContactedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchContacts = `-- name: SearchContacts :many
SELECT
    id, first_name, last_name, birthdate, source, status, address, city, state, zip_code, lender, price_range, timeframe, owner_id, created_at, updated_at, last_contacted_at
FROM
    contacts
WHERE
    owner_id = $1
    AND (
        first_name ilike $2
        OR last_name ilike $2
        OR concat(first_name, ' ', last_name) ilike $2
        OR address ilike $2
        OR city ilike $2
        OR state ilike $2
        OR lender ilike $2
        OR source ilike $2
    )
ORDER BY
    last_name,
    first_name
LIMIT
    50
`

type SearchContactsParams struct {
	OwnerID   uuid.NullUUID
	FirstName string
}

func (q *Queries) SearchContacts(ctx context.Context, arg SearchContactsParams) ([]Contact, error) {
	rows, err := q.db.QueryContext(ctx, searchContacts, arg.OwnerID, arg.FirstName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contact
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Birthdate,
			&i.Source,
			&i.Status,
			&i.Address,
			&i.City,
			&i.State,
			&i.ZipCode,
			&i.Lender,
			&i.PriceRange,
			&i.Timeframe,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastContactedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const testBulkInsertContacts = `-- name: TestBulkInsertContacts :many
INSERT INTO
    contacts (
        first_name,
        last_name,
        birthdate,
        source,
        STATUS,
        address,
        city,
        state,
        zip_code,
        lender,
        price_range,
        timeframe,
        owner_id
    )
SELECT
    c.first_name,
    c.last_name,
    c.birthdate,
    c.source,
    c.status,
    c.address,
    c.city,
    c.state,
    c.zip_code,
    c.lender,
    c.price_range,
    c.timeframe,
    c.owner_id
FROM
    jsonb_to_recordset($1::jsonb) AS c(
        first_name text,
        last_name text,
        birthdate date,
        source text,
        STATUS text,
        address text,
        city text,
        state text,
        zip_code text,
        lender text,
        price_range text,
        timeframe text,
        owner_id uuid
    )
RETURNING
    id
`

func (q *Queries) TestBulkInsertContacts(ctx context.Context, dollar_1 json.RawMessage) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, testBulkInsertContacts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateContact = `-- name: UpdateContact :one
UPDATE
    contacts
SET
    first_name = $2,
    last_name = $3,
    birthdate = $4,
    source = $5,
    STATUS = $6,
    address = $7,
    city = $8,
    state = $9,
    zip_code = $10,
    lender = $11,
    price_range = $12,
    timeframe = $13,
    updated_at = NOW()
WHERE
    id = $1
RETURNING
    id, first_name, last_name, birthdate, source, status, address, city, state, zip_code, lender, price_range, timeframe, owner_id, created_at, updated_at, last_contacted_at
`

type UpdateContactParams struct {
	ID         uuid.UUID
	FirstName  string
	LastName   string
	Birthdate  sql.NullTime
	Source     sql.NullString
	Status     sql.NullString
	Address    sql.NullString
	City       sql.NullString
	State      sql.NullString
	ZipCode    sql.NullString
	Lender     sql.NullString
	PriceRange sql.NullString
	Timeframe  sql.NullString
}

func (q *Queries) UpdateContact(ctx context.Context, arg UpdateContactParams) (Contact, error) {
	row := q.db.QueryRowContext(ctx, updateContact,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Birthdate,
		arg.Source,
		arg.Status,
		arg.Address,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.Lender,
		arg.PriceRange,
		arg.Timeframe,
	)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Birthdate,
		&i.Source,
		&i.Status,
		&i.Address,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.Lender,
		&i.PriceRange,
		&i.Timeframe,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastContactedAt,
	)
	return i, err
}
