// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: dashboard.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const appointmentsThisWeek = `-- name: AppointmentsThisWeek :one
SELECT
    count(*) AS appointments_this_week
FROM
    appointments
WHERE
    scheduled_at >= date_trunc('week', current_date)
    AND scheduled_at < date_trunc('week', current_date) + INTERVAL '7 days'
    AND outcome = 'no-outcome'
    AND assigned_to_id = $1
`

func (q *Queries) AppointmentsThisWeek(ctx context.Context, assignedToID uuid.NullUUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, appointmentsThisWeek, assignedToID)
	var appointments_this_week int64
	err := row.Scan(&appointments_this_week)
	return appointments_this_week, err
}

const contactsCount = `-- name: ContactsCount :one
SELECT
    count(*) AS total_contacts
FROM
    contacts
WHERE
    owner_id = $1
`

func (q *Queries) ContactsCount(ctx context.Context, ownerID uuid.NullUUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, contactsCount, ownerID)
	var total_contacts int64
	err := row.Scan(&total_contacts)
	return total_contacts, err
}

const get5NewestContacts = `-- name: Get5NewestContacts :many
SELECT
    c.id,
    c.first_name,
    c.last_name,
    c.birthdate,
    c.source,
    c.status,
    c.address,
    c.city,
    c.state,
    c.zip_code,
    c.lender,
    c.price_range,
    c.timeframe,
    c.owner_id,
    c.created_at,
    c.updated_at,
    c.last_contacted_at,
    -- Aggregate emails
    coalesce(
        jsonb_agg(
            DISTINCT jsonb_build_object(
                'id',
                e.id,
                'email_address',
                e.email_address,
                'type',
                e.type,
                'is_primary',
                e.is_primary
            )
        ) filter (
            WHERE
                e.id IS NOT NULL
        ),
        '[]'::jsonb
    ) AS emails,
    -- Aggregate phones
    coalesce(
        jsonb_agg(
            DISTINCT jsonb_build_object(
                'id',
                p.id,
                'phone_number',
                p.phone_number,
                'type',
                p.type,
                'is_primary',
                p.is_primary
            )
        ) filter (
            WHERE
                p.id IS NOT NULL
        ),
        '[]'::jsonb
    ) AS phone_numbers
FROM
    contacts c
    LEFT JOIN emails e ON e.contact_id = c.id
    LEFT JOIN phone_numbers p ON p.contact_id = c.id
WHERE
    c.owner_id = $1
GROUP BY
    c.id
ORDER BY
    c.created_at DESC
LIMIT
    5
`

type Get5NewestContactsRow struct {
	ID              uuid.UUID
	FirstName       string
	LastName        string
	Birthdate       sql.NullTime
	Source          sql.NullString
	Status          sql.NullString
	Address         sql.NullString
	City            sql.NullString
	State           sql.NullString
	ZipCode         sql.NullString
	Lender          sql.NullString
	PriceRange      sql.NullString
	Timeframe       sql.NullString
	OwnerID         uuid.NullUUID
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
	LastContactedAt sql.NullTime
	Emails          interface{}
	PhoneNumbers    interface{}
}

func (q *Queries) Get5NewestContacts(ctx context.Context, ownerID uuid.NullUUID) ([]Get5NewestContactsRow, error) {
	rows, err := q.db.QueryContext(ctx, get5NewestContacts, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Get5NewestContactsRow
	for rows.Next() {
		var i Get5NewestContactsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Birthdate,
			&i.Source,
			&i.Status,
			&i.Address,
			&i.City,
			&i.State,
			&i.ZipCode,
			&i.Lender,
			&i.PriceRange,
			&i.Timeframe,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastContactedAt,
			&i.Emails,
			&i.PhoneNumbers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingAppointments = `-- name: GetUpcomingAppointments :many
SELECT
    id, contact_id, assigned_to_id, title, scheduled_at, location, type, outcome, note, created_at, updated_at
FROM
    appointments a
WHERE
    a.scheduled_at >= current_date
    AND a.status = 'scheduled'
    AND a.assigned_to_id = $1
ORDER BY
    a.scheduled_at ASC
LIMIT
    5
`

func (q *Queries) GetUpcomingAppointments(ctx context.Context, assignedToID uuid.NullUUID) ([]Appointment, error) {
	rows, err := q.db.QueryContext(ctx, getUpcomingAppointments, assignedToID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Appointment
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.AssignedToID,
			&i.Title,
			&i.ScheduledAt,
			&i.Location,
			&i.Type,
			&i.Outcome,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newContactsThisMonth = `-- name: NewContactsThisMonth :one
SELECT
    count(*) AS new_contacts
FROM
    contacts
WHERE
    created_at >= date_trunc('month', current_date)
    AND owner_id = $1
`

func (q *Queries) NewContactsThisMonth(ctx context.Context, ownerID uuid.NullUUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, newContactsThisMonth, ownerID)
	var new_contacts int64
	err := row.Scan(&new_contacts)
	return new_contacts, err
}

const tasksDueTodayCount = `-- name: TasksDueTodayCount :one
SELECT
    count(*) AS tasks_due_today
FROM
    tasks
WHERE
    date = current_date
    AND STATUS = 'pending'
    AND assigned_to_id = $1
`

func (q *Queries) TasksDueTodayCount(ctx context.Context, assignedToID uuid.NullUUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, tasksDueTodayCount, assignedToID)
	var tasks_due_today int64
	err := row.Scan(&tasks_due_today)
	return tasks_due_today, err
}
