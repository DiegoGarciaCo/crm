// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: deals.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const countDeals = `-- name: CountDeals :one
SELECT
    count(*)
FROM
    deals
WHERE
    assigned_to_id = $1
`

func (q *Queries) CountDeals(ctx context.Context, assignedToID uuid.NullUUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDeals, assignedToID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDealsByStage = `-- name: CountDealsByStage :one
SELECT
    count(*)
FROM
    deals
WHERE
    stage_id = $1
    AND assigned_to_id = $2
`

type CountDealsByStageParams struct {
	StageID      uuid.NullUUID
	AssignedToID uuid.NullUUID
}

func (q *Queries) CountDealsByStage(ctx context.Context, arg CountDealsByStageParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDealsByStage, arg.StageID, arg.AssignedToID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDeal = `-- name: CreateDeal :one
INSERT INTO
    deals (
        contact_id,
        assigned_to_id,
        title,
        price,
        closing_date,
        earnest_money_due_date,
        mutual_acceptance_date,
        inspection_date,
        appraisal_date,
        final_walkthrough_date,
        possession_date,
        closed_date,
        commission,
        commission_split,
        property_address,
        property_city,
        property_state,
        property_zip_code,
        description,
        stage_id
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16,
        $17,
        $18,
        $19,
        $20
    )
RETURNING
    id, contact_id, assigned_to_id, title, price, closing_date, earnest_money_due_date, mutual_acceptance_date, inspection_date, appraisal_date, final_walkthrough_date, possession_date, commission, commission_split, property_address, property_city, property_state, property_zip_code, description, stage_id, created_at, updated_at, closed_date
`

type CreateDealParams struct {
	ContactID            uuid.NullUUID
	AssignedToID         uuid.NullUUID
	Title                string
	Price                int32
	ClosingDate          sql.NullTime
	EarnestMoneyDueDate  sql.NullTime
	MutualAcceptanceDate sql.NullTime
	InspectionDate       sql.NullTime
	AppraisalDate        sql.NullTime
	FinalWalkthroughDate sql.NullTime
	PossessionDate       sql.NullTime
	ClosedDate           sql.NullTime
	Commission           sql.NullInt32
	CommissionSplit      sql.NullInt32
	PropertyAddress      sql.NullString
	PropertyCity         sql.NullString
	PropertyState        sql.NullString
	PropertyZipCode      sql.NullString
	Description          sql.NullString
	StageID              uuid.NullUUID
}

func (q *Queries) CreateDeal(ctx context.Context, arg CreateDealParams) (Deal, error) {
	row := q.db.QueryRowContext(ctx, createDeal,
		arg.ContactID,
		arg.AssignedToID,
		arg.Title,
		arg.Price,
		arg.ClosingDate,
		arg.EarnestMoneyDueDate,
		arg.MutualAcceptanceDate,
		arg.InspectionDate,
		arg.AppraisalDate,
		arg.FinalWalkthroughDate,
		arg.PossessionDate,
		arg.ClosedDate,
		arg.Commission,
		arg.CommissionSplit,
		arg.PropertyAddress,
		arg.PropertyCity,
		arg.PropertyState,
		arg.PropertyZipCode,
		arg.Description,
		arg.StageID,
	)
	var i Deal
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.AssignedToID,
		&i.Title,
		&i.Price,
		&i.ClosingDate,
		&i.EarnestMoneyDueDate,
		&i.MutualAcceptanceDate,
		&i.InspectionDate,
		&i.AppraisalDate,
		&i.FinalWalkthroughDate,
		&i.PossessionDate,
		&i.Commission,
		&i.CommissionSplit,
		&i.PropertyAddress,
		&i.PropertyCity,
		&i.PropertyState,
		&i.PropertyZipCode,
		&i.Description,
		&i.StageID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedDate,
	)
	return i, err
}

const deleteDeal = `-- name: DeleteDeal :exec
DELETE FROM
    deals
WHERE
    id = $1
RETURNING
    id, contact_id, assigned_to_id, title, price, closing_date, earnest_money_due_date, mutual_acceptance_date, inspection_date, appraisal_date, final_walkthrough_date, possession_date, commission, commission_split, property_address, property_city, property_state, property_zip_code, description, stage_id, created_at, updated_at, closed_date
`

func (q *Queries) DeleteDeal(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteDeal, id)
	return err
}

const getDealById = `-- name: GetDealById :one
SELECT
    id, contact_id, assigned_to_id, title, price, closing_date, earnest_money_due_date, mutual_acceptance_date, inspection_date, appraisal_date, final_walkthrough_date, possession_date, commission, commission_split, property_address, property_city, property_state, property_zip_code, description, stage_id, created_at, updated_at, closed_date
FROM
    deals
WHERE
    id = $1
`

func (q *Queries) GetDealById(ctx context.Context, id uuid.UUID) (Deal, error) {
	row := q.db.QueryRowContext(ctx, getDealById, id)
	var i Deal
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.AssignedToID,
		&i.Title,
		&i.Price,
		&i.ClosingDate,
		&i.EarnestMoneyDueDate,
		&i.MutualAcceptanceDate,
		&i.InspectionDate,
		&i.AppraisalDate,
		&i.FinalWalkthroughDate,
		&i.PossessionDate,
		&i.Commission,
		&i.CommissionSplit,
		&i.PropertyAddress,
		&i.PropertyCity,
		&i.PropertyState,
		&i.PropertyZipCode,
		&i.Description,
		&i.StageID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedDate,
	)
	return i, err
}

const listDeals = `-- name: ListDeals :many
SELECT
    id, contact_id, assigned_to_id, title, price, closing_date, earnest_money_due_date, mutual_acceptance_date, inspection_date, appraisal_date, final_walkthrough_date, possession_date, commission, commission_split, property_address, property_city, property_state, property_zip_code, description, stage_id, created_at, updated_at, closed_date
FROM
    deals
WHERE
    assigned_to_id = $3
ORDER BY
    created_at DESC
LIMIT
    $1 OFFSET $2
`

type ListDealsParams struct {
	Limit        int32
	Offset       int32
	AssignedToID uuid.NullUUID
}

func (q *Queries) ListDeals(ctx context.Context, arg ListDealsParams) ([]Deal, error) {
	rows, err := q.db.QueryContext(ctx, listDeals, arg.Limit, arg.Offset, arg.AssignedToID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Deal
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.AssignedToID,
			&i.Title,
			&i.Price,
			&i.ClosingDate,
			&i.EarnestMoneyDueDate,
			&i.MutualAcceptanceDate,
			&i.InspectionDate,
			&i.AppraisalDate,
			&i.FinalWalkthroughDate,
			&i.PossessionDate,
			&i.Commission,
			&i.CommissionSplit,
			&i.PropertyAddress,
			&i.PropertyCity,
			&i.PropertyState,
			&i.PropertyZipCode,
			&i.Description,
			&i.StageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDealsByContactID = `-- name: ListDealsByContactID :many
SELECT
    id, contact_id, assigned_to_id, title, price, closing_date, earnest_money_due_date, mutual_acceptance_date, inspection_date, appraisal_date, final_walkthrough_date, possession_date, commission, commission_split, property_address, property_city, property_state, property_zip_code, description, stage_id, created_at, updated_at, closed_date
FROM
    deals
WHERE
    contact_id = $1
    AND assigned_to_id = $2
`

type ListDealsByContactIDParams struct {
	ContactID    uuid.NullUUID
	AssignedToID uuid.NullUUID
}

func (q *Queries) ListDealsByContactID(ctx context.Context, arg ListDealsByContactIDParams) ([]Deal, error) {
	rows, err := q.db.QueryContext(ctx, listDealsByContactID, arg.ContactID, arg.AssignedToID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Deal
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.AssignedToID,
			&i.Title,
			&i.Price,
			&i.ClosingDate,
			&i.EarnestMoneyDueDate,
			&i.MutualAcceptanceDate,
			&i.InspectionDate,
			&i.AppraisalDate,
			&i.FinalWalkthroughDate,
			&i.PossessionDate,
			&i.Commission,
			&i.CommissionSplit,
			&i.PropertyAddress,
			&i.PropertyCity,
			&i.PropertyState,
			&i.PropertyZipCode,
			&i.Description,
			&i.StageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDealsByStage = `-- name: ListDealsByStage :many
SELECT
    id, contact_id, assigned_to_id, title, price, closing_date, earnest_money_due_date, mutual_acceptance_date, inspection_date, appraisal_date, final_walkthrough_date, possession_date, commission, commission_split, property_address, property_city, property_state, property_zip_code, description, stage_id, created_at, updated_at, closed_date
FROM
    deals
WHERE
    stage_id = $1
    AND assigned_to_id = $4
ORDER BY
    created_at DESC
LIMIT
    $2 OFFSET $3
`

type ListDealsByStageParams struct {
	StageID      uuid.NullUUID
	Limit        int32
	Offset       int32
	AssignedToID uuid.NullUUID
}

func (q *Queries) ListDealsByStage(ctx context.Context, arg ListDealsByStageParams) ([]Deal, error) {
	rows, err := q.db.QueryContext(ctx, listDealsByStage,
		arg.StageID,
		arg.Limit,
		arg.Offset,
		arg.AssignedToID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Deal
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.AssignedToID,
			&i.Title,
			&i.Price,
			&i.ClosingDate,
			&i.EarnestMoneyDueDate,
			&i.MutualAcceptanceDate,
			&i.InspectionDate,
			&i.AppraisalDate,
			&i.FinalWalkthroughDate,
			&i.PossessionDate,
			&i.Commission,
			&i.CommissionSplit,
			&i.PropertyAddress,
			&i.PropertyCity,
			&i.PropertyState,
			&i.PropertyZipCode,
			&i.Description,
			&i.StageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeal = `-- name: UpdateDeal :one
UPDATE
    deals
SET
    contact_id = $2,
    assigned_to_id = $3,
    title = $4,
    price = $5,
    closing_date = $6,
    earnest_money_due_date = $7,
    mutual_acceptance_date = $8,
    inspection_date = $9,
    appraisal_date = $10,
    final_walkthrough_date = $11,
    possession_date = $12,
    commission = $13,
    commission_split = $14,
    property_address = $15,
    property_city = $16,
    property_state = $17,
    property_zip_code = $18,
    description = $19,
    stage_id = $20,
    closed_date = $21
WHERE
    id = $1
RETURNING
    id, contact_id, assigned_to_id, title, price, closing_date, earnest_money_due_date, mutual_acceptance_date, inspection_date, appraisal_date, final_walkthrough_date, possession_date, commission, commission_split, property_address, property_city, property_state, property_zip_code, description, stage_id, created_at, updated_at, closed_date
`

type UpdateDealParams struct {
	ID                   uuid.UUID
	ContactID            uuid.NullUUID
	AssignedToID         uuid.NullUUID
	Title                string
	Price                int32
	ClosingDate          sql.NullTime
	EarnestMoneyDueDate  sql.NullTime
	MutualAcceptanceDate sql.NullTime
	InspectionDate       sql.NullTime
	AppraisalDate        sql.NullTime
	FinalWalkthroughDate sql.NullTime
	PossessionDate       sql.NullTime
	Commission           sql.NullInt32
	CommissionSplit      sql.NullInt32
	PropertyAddress      sql.NullString
	PropertyCity         sql.NullString
	PropertyState        sql.NullString
	PropertyZipCode      sql.NullString
	Description          sql.NullString
	StageID              uuid.NullUUID
	ClosedDate           sql.NullTime
}

func (q *Queries) UpdateDeal(ctx context.Context, arg UpdateDealParams) (Deal, error) {
	row := q.db.QueryRowContext(ctx, updateDeal,
		arg.ID,
		arg.ContactID,
		arg.AssignedToID,
		arg.Title,
		arg.Price,
		arg.ClosingDate,
		arg.EarnestMoneyDueDate,
		arg.MutualAcceptanceDate,
		arg.InspectionDate,
		arg.AppraisalDate,
		arg.FinalWalkthroughDate,
		arg.PossessionDate,
		arg.Commission,
		arg.CommissionSplit,
		arg.PropertyAddress,
		arg.PropertyCity,
		arg.PropertyState,
		arg.PropertyZipCode,
		arg.Description,
		arg.StageID,
		arg.ClosedDate,
	)
	var i Deal
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.AssignedToID,
		&i.Title,
		&i.Price,
		&i.ClosingDate,
		&i.EarnestMoneyDueDate,
		&i.MutualAcceptanceDate,
		&i.InspectionDate,
		&i.AppraisalDate,
		&i.FinalWalkthroughDate,
		&i.PossessionDate,
		&i.Commission,
		&i.CommissionSplit,
		&i.PropertyAddress,
		&i.PropertyCity,
		&i.PropertyState,
		&i.PropertyZipCode,
		&i.Description,
		&i.StageID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedDate,
	)
	return i, err
}
